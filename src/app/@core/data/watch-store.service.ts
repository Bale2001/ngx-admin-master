//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IWatchStore {
    /**
     * @return Success
     */
    adminsAll(): Observable<Admin[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    adminsPOST(body?: Admin | undefined): Observable<Admin>;
    /**
     * @return Success
     */
    adminsGET(id: number): Observable<Admin>;
    /**
     * @param body (optional) 
     * @return Success
     */
    adminsPUT(id: number, body?: Admin | undefined): Observable<void>;
    /**
     * @return Success
     */
    adminsDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    categoriesAll(): Observable<Category[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    categoriesPOST(body?: Category | undefined): Observable<Category>;
    /**
     * @return Success
     */
    categoriesGET(id: number): Observable<Category>;
    /**
     * @param body (optional) 
     * @return Success
     */
    categoriesPUT(id: number, body?: Category | undefined): Observable<void>;
    /**
     * @return Success
     */
    categoriesDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    listCategory(): Observable<GetAllCategory[]>;
    /**
     * @return Success
     */
    commentsAll(): Observable<Comment[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    commentsPOST(body?: Comment | undefined): Observable<Comment>;
    /**
     * @return Success
     */
    commentsGET(id: number): Observable<Comment>;
    /**
     * @param body (optional) 
     * @return Success
     */
    commentsPUT(id: number, body?: Comment | undefined): Observable<void>;
    /**
     * @return Success
     */
    commentsDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    feedbacksAll(): Observable<Feedback[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    feedbacksPOST(body?: Feedback | undefined): Observable<Feedback>;
    /**
     * @return Success
     */
    feedbacksGET(id: number): Observable<Feedback>;
    /**
     * @param body (optional) 
     * @return Success
     */
    feedbacksPUT(id: number, body?: Feedback | undefined): Observable<void>;
    /**
     * @return Success
     */
    feedbacksDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    imagesAll(): Observable<Image[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    imagesPOST(body?: Image | undefined): Observable<Image>;
    /**
     * @return Success
     */
    imagesGET(id: number): Observable<Image>;
    /**
     * @param body (optional) 
     * @return Success
     */
    imagesPUT(id: number, body?: Image | undefined): Observable<void>;
    /**
     * @return Success
     */
    imagesDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    orderDetailsAll(): Observable<OrderDetail[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    orderDetailsPOST(body?: OrderDetail | undefined): Observable<OrderDetail>;
    /**
     * @return Success
     */
    orderDetailsGET(id: number): Observable<OrderDetail>;
    /**
     * @param body (optional) 
     * @return Success
     */
    orderDetailsPUT(id: number, body?: OrderDetail | undefined): Observable<void>;
    /**
     * @return Success
     */
    orderDetailsDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    ordersAll(): Observable<Order[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    ordersPOST(body?: Order | undefined): Observable<Order>;
    /**
     * @return Success
     */
    ordersGET(id: number): Observable<Order>;
    /**
     * @param body (optional) 
     * @return Success
     */
    ordersPUT(id: number, body?: Order | undefined): Observable<void>;
    /**
     * @return Success
     */
    ordersDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    originalsAll(): Observable<Original[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    originalsPOST(body?: Original | undefined): Observable<Original>;
    /**
     * @return Success
     */
    originalsGET(id: number): Observable<Original>;
    /**
     * @param body (optional) 
     * @return Success
     */
    originalsPUT(id: number, body?: Original | undefined): Observable<void>;
    /**
     * @return Success
     */
    originalsDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    listOriginal(): Observable<GetAllOriginal[]>;
    /**
     * @return Success
     */
    productsAll(): Observable<Product[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    productsPOST(body?: Product | undefined): Observable<Product>;
    /**
     * @return Success
     */
    productsGET(id: number): Observable<Product>;
    /**
     * @param body (optional) 
     * @return Success
     */
    productsPUT(id: number, body?: Product | undefined): Observable<void>;
    /**
     * @return Success
     */
    productsDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    usersAll(): Observable<User[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    usersPOST(body?: User | undefined): Observable<User>;
    /**
     * @return Success
     */
    usersGET(id: number): Observable<User>;
    /**
     * @param body (optional) 
     * @return Success
     */
    usersPUT(id: number, body?: User | undefined): Observable<void>;
    /**
     * @return Success
     */
    usersDELETE(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class WatchStore implements IWatchStore {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    adminsAll(): Observable<Admin[]> {
        let url_ = this.baseUrl + "/api/Admins";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Admin[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Admin[]>;
        }));
    }

    protected processAdminsAll(response: HttpResponseBase): Observable<Admin[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Admin.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Admin[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    adminsPOST(body?: Admin | undefined): Observable<Admin> {
        let url_ = this.baseUrl + "/api/Admins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Admin>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Admin>;
        }));
    }

    protected processAdminsPOST(response: HttpResponseBase): Observable<Admin> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Admin.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Admin>(null as any);
    }

    /**
     * @return Success
     */
    adminsGET(id: number): Observable<Admin> {
        let url_ = this.baseUrl + "/api/Admins/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Admin>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Admin>;
        }));
    }

    protected processAdminsGET(response: HttpResponseBase): Observable<Admin> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Admin.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Admin>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    adminsPUT(id: number, body?: Admin | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Admins/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdminsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    adminsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Admins/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdminsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    categoriesAll(): Observable<Category[]> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category[]>;
        }));
    }

    protected processCategoriesAll(response: HttpResponseBase): Observable<Category[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categoriesPOST(body?: Category | undefined): Observable<Category> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category>;
        }));
    }

    protected processCategoriesPOST(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category>(null as any);
    }

    /**
     * @return Success
     */
    categoriesGET(id: number): Observable<Category> {
        let url_ = this.baseUrl + "/api/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category>;
        }));
    }

    protected processCategoriesGET(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categoriesPUT(id: number, body?: Category | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCategoriesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    categoriesDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCategoriesDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    listCategory(): Observable<GetAllCategory[]> {
        let url_ = this.baseUrl + "/api/Categories/ListCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllCategory[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllCategory[]>;
        }));
    }

    protected processListCategory(response: HttpResponseBase): Observable<GetAllCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllCategory.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllCategory[]>(null as any);
    }

    /**
     * @return Success
     */
    commentsAll(): Observable<Comment[]> {
        let url_ = this.baseUrl + "/api/Comments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Comment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Comment[]>;
        }));
    }

    protected processCommentsAll(response: HttpResponseBase): Observable<Comment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Comment.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Comment[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentsPOST(body?: Comment | undefined): Observable<Comment> {
        let url_ = this.baseUrl + "/api/Comments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Comment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Comment>;
        }));
    }

    protected processCommentsPOST(response: HttpResponseBase): Observable<Comment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Comment.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Comment>(null as any);
    }

    /**
     * @return Success
     */
    commentsGET(id: number): Observable<Comment> {
        let url_ = this.baseUrl + "/api/Comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Comment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Comment>;
        }));
    }

    protected processCommentsGET(response: HttpResponseBase): Observable<Comment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Comment.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Comment>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentsPUT(id: number, body?: Comment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCommentsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    commentsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCommentsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    feedbacksAll(): Observable<Feedback[]> {
        let url_ = this.baseUrl + "/api/Feedbacks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedbacksAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedbacksAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Feedback[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Feedback[]>;
        }));
    }

    protected processFeedbacksAll(response: HttpResponseBase): Observable<Feedback[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Feedback.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Feedback[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    feedbacksPOST(body?: Feedback | undefined): Observable<Feedback> {
        let url_ = this.baseUrl + "/api/Feedbacks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedbacksPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedbacksPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Feedback>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Feedback>;
        }));
    }

    protected processFeedbacksPOST(response: HttpResponseBase): Observable<Feedback> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Feedback.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Feedback>(null as any);
    }

    /**
     * @return Success
     */
    feedbacksGET(id: number): Observable<Feedback> {
        let url_ = this.baseUrl + "/api/Feedbacks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedbacksGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedbacksGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Feedback>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Feedback>;
        }));
    }

    protected processFeedbacksGET(response: HttpResponseBase): Observable<Feedback> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Feedback.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Feedback>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    feedbacksPUT(id: number, body?: Feedback | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Feedbacks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedbacksPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedbacksPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFeedbacksPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    feedbacksDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Feedbacks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedbacksDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedbacksDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFeedbacksDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    imagesAll(): Observable<Image[]> {
        let url_ = this.baseUrl + "/api/Images";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImagesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImagesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Image[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Image[]>;
        }));
    }

    protected processImagesAll(response: HttpResponseBase): Observable<Image[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Image.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Image[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    imagesPOST(body?: Image | undefined): Observable<Image> {
        let url_ = this.baseUrl + "/api/Images";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImagesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImagesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Image>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Image>;
        }));
    }

    protected processImagesPOST(response: HttpResponseBase): Observable<Image> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Image.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Image>(null as any);
    }

    /**
     * @return Success
     */
    imagesGET(id: number): Observable<Image> {
        let url_ = this.baseUrl + "/api/Images/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImagesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImagesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Image>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Image>;
        }));
    }

    protected processImagesGET(response: HttpResponseBase): Observable<Image> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Image.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Image>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    imagesPUT(id: number, body?: Image | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Images/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImagesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImagesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImagesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    imagesDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Images/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImagesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImagesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImagesDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    orderDetailsAll(): Observable<OrderDetail[]> {
        let url_ = this.baseUrl + "/api/OrderDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderDetailsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderDetailsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetail[]>;
        }));
    }

    protected processOrderDetailsAll(response: HttpResponseBase): Observable<OrderDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderDetail.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDetail[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    orderDetailsPOST(body?: OrderDetail | undefined): Observable<OrderDetail> {
        let url_ = this.baseUrl + "/api/OrderDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderDetailsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderDetailsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetail>;
        }));
    }

    protected processOrderDetailsPOST(response: HttpResponseBase): Observable<OrderDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = OrderDetail.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDetail>(null as any);
    }

    /**
     * @return Success
     */
    orderDetailsGET(id: number): Observable<OrderDetail> {
        let url_ = this.baseUrl + "/api/OrderDetails/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderDetailsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderDetailsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetail>;
        }));
    }

    protected processOrderDetailsGET(response: HttpResponseBase): Observable<OrderDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = OrderDetail.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDetail>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    orderDetailsPUT(id: number, body?: OrderDetail | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OrderDetails/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderDetailsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderDetailsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOrderDetailsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    orderDetailsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/OrderDetails/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderDetailsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderDetailsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOrderDetailsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    ordersAll(): Observable<Order[]> {
        let url_ = this.baseUrl + "/api/Orders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order[]>;
        }));
    }

    protected processOrdersAll(response: HttpResponseBase): Observable<Order[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Order.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Order[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ordersPOST(body?: Order | undefined): Observable<Order> {
        let url_ = this.baseUrl + "/api/Orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order>;
        }));
    }

    protected processOrdersPOST(response: HttpResponseBase): Observable<Order> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Order.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Order>(null as any);
    }

    /**
     * @return Success
     */
    ordersGET(id: number): Observable<Order> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order>;
        }));
    }

    protected processOrdersGET(response: HttpResponseBase): Observable<Order> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Order.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Order>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ordersPUT(id: number, body?: Order | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOrdersPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    ordersDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOrdersDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    originalsAll(): Observable<Original[]> {
        let url_ = this.baseUrl + "/api/Originals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOriginalsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOriginalsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Original[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Original[]>;
        }));
    }

    protected processOriginalsAll(response: HttpResponseBase): Observable<Original[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Original.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Original[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    originalsPOST(body?: Original | undefined): Observable<Original> {
        let url_ = this.baseUrl + "/api/Originals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOriginalsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOriginalsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Original>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Original>;
        }));
    }

    protected processOriginalsPOST(response: HttpResponseBase): Observable<Original> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Original.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Original>(null as any);
    }

    /**
     * @return Success
     */
    originalsGET(id: number): Observable<Original> {
        let url_ = this.baseUrl + "/api/Originals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOriginalsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOriginalsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Original>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Original>;
        }));
    }

    protected processOriginalsGET(response: HttpResponseBase): Observable<Original> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Original.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Original>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    originalsPUT(id: number, body?: Original | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Originals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOriginalsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOriginalsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOriginalsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    originalsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Originals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOriginalsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOriginalsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOriginalsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    listOriginal(): Observable<GetAllOriginal[]> {
        let url_ = this.baseUrl + "/api/Originals/ListOriginal";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListOriginal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListOriginal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllOriginal[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllOriginal[]>;
        }));
    }

    protected processListOriginal(response: HttpResponseBase): Observable<GetAllOriginal[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllOriginal.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllOriginal[]>(null as any);
    }

    /**
     * @return Success
     */
    productsAll(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product[]>;
        }));
    }

    protected processProductsAll(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Product.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productsPOST(body?: Product | undefined): Observable<Product> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processProductsPOST(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(null as any);
    }

    /**
     * @return Success
     */
    productsGET(id: number): Observable<Product> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processProductsGET(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productsPUT(id: number, body?: Product | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProductsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    productsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProductsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    usersAll(): Observable<User[]> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User[]>;
        }));
    }

    protected processUsersAll(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPOST(body?: User | undefined): Observable<User> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processUsersPOST(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(null as any);
    }

    /**
     * @return Success
     */
    usersGET(id: number): Observable<User> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processUsersGET(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPUT(id: number, body?: User | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUsersPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    usersDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUsersDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export class Admin implements IAdmin {
    id?: number;
    username?: string | undefined;
    password?: string | undefined;
    name?: string | undefined;
    phone?: number | undefined;
    email?: string | undefined;
    permission?: number | undefined;
    status?: boolean | undefined;

    constructor(data?: IAdmin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.permission = _data["permission"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any, _mappings?: any): Admin | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Admin>(data, _mappings, Admin);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["password"] = this.password;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["permission"] = this.permission;
        data["status"] = this.status;
        return data;
    }
}

export interface IAdmin {
    id?: number;
    username?: string | undefined;
    password?: string | undefined;
    name?: string | undefined;
    phone?: number | undefined;
    email?: string | undefined;
    permission?: number | undefined;
    status?: boolean | undefined;
}

export class Category implements ICategory {
    catId?: number;
    catName?: string | undefined;
    catMetaTitle?: string | undefined;
    catStatus?: boolean | undefined;
    catDescription?: string | undefined;
    readonly products?: Product[] | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.products) {
                this.products = [];
                for (let i = 0; i < data.products.length; i++) {
                    let item = data.products[i];
                    this.products[i] = item && !(<any>item).toJSON ? new Product(item) : <Product>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.catId = _data["catId"];
            this.catName = _data["catName"];
            this.catMetaTitle = _data["catMetaTitle"];
            this.catStatus = _data["catStatus"];
            this.catDescription = _data["catDescription"];
            if (Array.isArray(_data["products"])) {
                (<any>this).products = [] as any;
                for (let item of _data["products"])
                    (<any>this).products!.push(Product.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Category | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Category>(data, _mappings, Category);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catId"] = this.catId;
        data["catName"] = this.catName;
        data["catMetaTitle"] = this.catMetaTitle;
        data["catStatus"] = this.catStatus;
        data["catDescription"] = this.catDescription;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategory {
    catId?: number;
    catName?: string | undefined;
    catMetaTitle?: string | undefined;
    catStatus?: boolean | undefined;
    catDescription?: string | undefined;
    products?: IProduct[] | undefined;
}

export class Comment implements IComment {
    comId?: number;
    proId?: number | undefined;
    userId?: number | undefined;
    comContent?: string | undefined;
    pro?: Product;
    user?: User;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.pro = data.pro && !(<any>data.pro).toJSON ? new Product(data.pro) : <Product>this.pro;
            this.user = data.user && !(<any>data.user).toJSON ? new User(data.user) : <User>this.user;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.comId = _data["comId"];
            this.proId = _data["proId"];
            this.userId = _data["userId"];
            this.comContent = _data["comContent"];
            this.pro = _data["pro"] ? Product.fromJS(_data["pro"], _mappings) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Comment | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Comment>(data, _mappings, Comment);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comId"] = this.comId;
        data["proId"] = this.proId;
        data["userId"] = this.userId;
        data["comContent"] = this.comContent;
        data["pro"] = this.pro ? this.pro.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IComment {
    comId?: number;
    proId?: number | undefined;
    userId?: number | undefined;
    comContent?: string | undefined;
    pro?: IProduct;
    user?: IUser;
}

export class Feedback implements IFeedback {
    febId?: number;
    userId?: number | undefined;
    febDate?: Date | undefined;
    febTitle?: string | undefined;
    febContent?: string | undefined;
    febReply?: string | undefined;
    febStatus?: string | undefined;
    user?: User;

    constructor(data?: IFeedback) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.user = data.user && !(<any>data.user).toJSON ? new User(data.user) : <User>this.user;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.febId = _data["febId"];
            this.userId = _data["userId"];
            this.febDate = _data["febDate"] ? new Date(_data["febDate"].toString()) : <any>undefined;
            this.febTitle = _data["febTitle"];
            this.febContent = _data["febContent"];
            this.febReply = _data["febReply"];
            this.febStatus = _data["febStatus"];
            this.user = _data["user"] ? User.fromJS(_data["user"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Feedback | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Feedback>(data, _mappings, Feedback);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["febId"] = this.febId;
        data["userId"] = this.userId;
        data["febDate"] = this.febDate ? this.febDate.toISOString() : <any>undefined;
        data["febTitle"] = this.febTitle;
        data["febContent"] = this.febContent;
        data["febReply"] = this.febReply;
        data["febStatus"] = this.febStatus;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFeedback {
    febId?: number;
    userId?: number | undefined;
    febDate?: Date | undefined;
    febTitle?: string | undefined;
    febContent?: string | undefined;
    febReply?: string | undefined;
    febStatus?: string | undefined;
    user?: IUser;
}

export class GetAllCategory implements IGetAllCategory {
    id?: number;
    name?: string | undefined;

    constructor(data?: IGetAllCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): GetAllCategory | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetAllCategory>(data, _mappings, GetAllCategory);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IGetAllCategory {
    id?: number;
    name?: string | undefined;
}

export class GetAllOriginal implements IGetAllOriginal {
    id?: number;
    name?: string | undefined;

    constructor(data?: IGetAllOriginal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): GetAllOriginal | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetAllOriginal>(data, _mappings, GetAllOriginal);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IGetAllOriginal {
    id?: number;
    name?: string | undefined;
}

export class Image implements IImage {
    imgId?: number;
    proId?: number | undefined;
    imgFile?: string | undefined;
    pro?: Product;

    constructor(data?: IImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.pro = data.pro && !(<any>data.pro).toJSON ? new Product(data.pro) : <Product>this.pro;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.imgId = _data["imgId"];
            this.proId = _data["proId"];
            this.imgFile = _data["imgFile"];
            this.pro = _data["pro"] ? Product.fromJS(_data["pro"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Image | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Image>(data, _mappings, Image);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imgId"] = this.imgId;
        data["proId"] = this.proId;
        data["imgFile"] = this.imgFile;
        data["pro"] = this.pro ? this.pro.toJSON() : <any>undefined;
        return data;
    }
}

export interface IImage {
    imgId?: number;
    proId?: number | undefined;
    imgFile?: string | undefined;
    pro?: IProduct;
}

export class Order implements IOrder {
    orId?: number;
    orCode?: string | undefined;
    orDate?: Date | undefined;
    orPrice?: number | undefined;
    orAddressTo?: string | undefined;
    orStatus?: string | undefined;
    userId?: number | undefined;
    readonly orderDetails?: OrderDetail[] | undefined;
    user?: User;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.orderDetails) {
                this.orderDetails = [];
                for (let i = 0; i < data.orderDetails.length; i++) {
                    let item = data.orderDetails[i];
                    this.orderDetails[i] = item && !(<any>item).toJSON ? new OrderDetail(item) : <OrderDetail>item;
                }
            }
            this.user = data.user && !(<any>data.user).toJSON ? new User(data.user) : <User>this.user;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.orId = _data["orId"];
            this.orCode = _data["orCode"];
            this.orDate = _data["orDate"] ? new Date(_data["orDate"].toString()) : <any>undefined;
            this.orPrice = _data["orPrice"];
            this.orAddressTo = _data["orAddressTo"];
            this.orStatus = _data["orStatus"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["orderDetails"])) {
                (<any>this).orderDetails = [] as any;
                for (let item of _data["orderDetails"])
                    (<any>this).orderDetails!.push(OrderDetail.fromJS(item, _mappings));
            }
            this.user = _data["user"] ? User.fromJS(_data["user"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Order | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Order>(data, _mappings, Order);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orId"] = this.orId;
        data["orCode"] = this.orCode;
        data["orDate"] = this.orDate ? this.orDate.toISOString() : <any>undefined;
        data["orPrice"] = this.orPrice;
        data["orAddressTo"] = this.orAddressTo;
        data["orStatus"] = this.orStatus;
        data["userId"] = this.userId;
        if (Array.isArray(this.orderDetails)) {
            data["orderDetails"] = [];
            for (let item of this.orderDetails)
                data["orderDetails"].push(item.toJSON());
        }
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOrder {
    orId?: number;
    orCode?: string | undefined;
    orDate?: Date | undefined;
    orPrice?: number | undefined;
    orAddressTo?: string | undefined;
    orStatus?: string | undefined;
    userId?: number | undefined;
    orderDetails?: IOrderDetail[] | undefined;
    user?: IUser;
}

export class OrderDetail implements IOrderDetail {
    id?: number;
    proId?: number | undefined;
    orId?: number | undefined;
    price?: number | undefined;
    quantity?: number | undefined;
    or?: Order;
    pro?: Product;

    constructor(data?: IOrderDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.or = data.or && !(<any>data.or).toJSON ? new Order(data.or) : <Order>this.or;
            this.pro = data.pro && !(<any>data.pro).toJSON ? new Product(data.pro) : <Product>this.pro;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.proId = _data["proId"];
            this.orId = _data["orId"];
            this.price = _data["price"];
            this.quantity = _data["quantity"];
            this.or = _data["or"] ? Order.fromJS(_data["or"], _mappings) : <any>undefined;
            this.pro = _data["pro"] ? Product.fromJS(_data["pro"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): OrderDetail | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrderDetail>(data, _mappings, OrderDetail);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["proId"] = this.proId;
        data["orId"] = this.orId;
        data["price"] = this.price;
        data["quantity"] = this.quantity;
        data["or"] = this.or ? this.or.toJSON() : <any>undefined;
        data["pro"] = this.pro ? this.pro.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOrderDetail {
    id?: number;
    proId?: number | undefined;
    orId?: number | undefined;
    price?: number | undefined;
    quantity?: number | undefined;
    or?: IOrder;
    pro?: IProduct;
}

export class Original implements IOriginal {
    supplierId?: number;
    name?: string | undefined;
    address?: string | undefined;
    phone?: number | undefined;
    readonly products?: Product[] | undefined;

    constructor(data?: IOriginal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.products) {
                this.products = [];
                for (let i = 0; i < data.products.length; i++) {
                    let item = data.products[i];
                    this.products[i] = item && !(<any>item).toJSON ? new Product(item) : <Product>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.supplierId = _data["supplierId"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            if (Array.isArray(_data["products"])) {
                (<any>this).products = [] as any;
                for (let item of _data["products"])
                    (<any>this).products!.push(Product.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Original | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Original>(data, _mappings, Original);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierId"] = this.supplierId;
        data["name"] = this.name;
        data["address"] = this.address;
        data["phone"] = this.phone;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOriginal {
    supplierId?: number;
    name?: string | undefined;
    address?: string | undefined;
    phone?: number | undefined;
    products?: IProduct[] | undefined;
}

export class Product implements IProduct {
    proId?: number;
    proName?: string | undefined;
    proCode?: string | undefined;
    proPrice?: number | undefined;
    proQuantity?: number | undefined;
    proDescription?: string | undefined;
    proStatus?: boolean | undefined;
    proAvatar?: string | undefined;
    proSale?: boolean | undefined;
    proCreateDate?: Date | undefined;
    proCreateBy?: string | undefined;
    supplierId?: number | undefined;
    categoryId?: number | undefined;
    category?: Category;
    readonly comments?: Comment[] | undefined;
    readonly images?: Image[] | undefined;
    readonly orderDetails?: OrderDetail[] | undefined;
    supplier?: Original;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.category = data.category && !(<any>data.category).toJSON ? new Category(data.category) : <Category>this.category;
            if (data.comments) {
                this.comments = [];
                for (let i = 0; i < data.comments.length; i++) {
                    let item = data.comments[i];
                    this.comments[i] = item && !(<any>item).toJSON ? new Comment(item) : <Comment>item;
                }
            }
            if (data.images) {
                this.images = [];
                for (let i = 0; i < data.images.length; i++) {
                    let item = data.images[i];
                    this.images[i] = item && !(<any>item).toJSON ? new Image(item) : <Image>item;
                }
            }
            if (data.orderDetails) {
                this.orderDetails = [];
                for (let i = 0; i < data.orderDetails.length; i++) {
                    let item = data.orderDetails[i];
                    this.orderDetails[i] = item && !(<any>item).toJSON ? new OrderDetail(item) : <OrderDetail>item;
                }
            }
            this.supplier = data.supplier && !(<any>data.supplier).toJSON ? new Original(data.supplier) : <Original>this.supplier;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.proId = _data["proId"];
            this.proName = _data["proName"];
            this.proCode = _data["proCode"];
            this.proPrice = _data["proPrice"];
            this.proQuantity = _data["proQuantity"];
            this.proDescription = _data["proDescription"];
            this.proStatus = _data["proStatus"];
            this.proAvatar = _data["proAvatar"];
            this.proSale = _data["proSale"];
            this.proCreateDate = _data["proCreateDate"] ? new Date(_data["proCreateDate"].toString()) : <any>undefined;
            this.proCreateBy = _data["proCreateBy"];
            this.supplierId = _data["supplierId"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? Category.fromJS(_data["category"], _mappings) : <any>undefined;
            if (Array.isArray(_data["comments"])) {
                (<any>this).comments = [] as any;
                for (let item of _data["comments"])
                    (<any>this).comments!.push(Comment.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["images"])) {
                (<any>this).images = [] as any;
                for (let item of _data["images"])
                    (<any>this).images!.push(Image.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["orderDetails"])) {
                (<any>this).orderDetails = [] as any;
                for (let item of _data["orderDetails"])
                    (<any>this).orderDetails!.push(OrderDetail.fromJS(item, _mappings));
            }
            this.supplier = _data["supplier"] ? Original.fromJS(_data["supplier"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Product | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Product>(data, _mappings, Product);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["proId"] = this.proId;
        data["proName"] = this.proName;
        data["proCode"] = this.proCode;
        data["proPrice"] = this.proPrice;
        data["proQuantity"] = this.proQuantity;
        data["proDescription"] = this.proDescription;
        data["proStatus"] = this.proStatus;
        data["proAvatar"] = this.proAvatar;
        data["proSale"] = this.proSale;
        data["proCreateDate"] = this.proCreateDate ? this.proCreateDate.toISOString() : <any>undefined;
        data["proCreateBy"] = this.proCreateBy;
        data["supplierId"] = this.supplierId;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.orderDetails)) {
            data["orderDetails"] = [];
            for (let item of this.orderDetails)
                data["orderDetails"].push(item.toJSON());
        }
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProduct {
    proId?: number;
    proName?: string | undefined;
    proCode?: string | undefined;
    proPrice?: number | undefined;
    proQuantity?: number | undefined;
    proDescription?: string | undefined;
    proStatus?: boolean | undefined;
    proAvatar?: string | undefined;
    proSale?: boolean | undefined;
    proCreateDate?: Date | undefined;
    proCreateBy?: string | undefined;
    supplierId?: number | undefined;
    categoryId?: number | undefined;
    category?: ICategory;
    comments?: IComment[] | undefined;
    images?: IImage[] | undefined;
    orderDetails?: IOrderDetail[] | undefined;
    supplier?: IOriginal;
}

export class User implements IUser {
    userId?: number;
    email?: string | undefined;
    passworld?: string | undefined;
    name?: string | undefined;
    phone?: number | undefined;
    address?: string | undefined;
    birthday?: Date | undefined;
    status?: boolean | undefined;
    about?: string | undefined;
    readonly comments?: Comment[] | undefined;
    readonly feedbacks?: Feedback[] | undefined;
    readonly orders?: Order[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.comments) {
                this.comments = [];
                for (let i = 0; i < data.comments.length; i++) {
                    let item = data.comments[i];
                    this.comments[i] = item && !(<any>item).toJSON ? new Comment(item) : <Comment>item;
                }
            }
            if (data.feedbacks) {
                this.feedbacks = [];
                for (let i = 0; i < data.feedbacks.length; i++) {
                    let item = data.feedbacks[i];
                    this.feedbacks[i] = item && !(<any>item).toJSON ? new Feedback(item) : <Feedback>item;
                }
            }
            if (data.orders) {
                this.orders = [];
                for (let i = 0; i < data.orders.length; i++) {
                    let item = data.orders[i];
                    this.orders[i] = item && !(<any>item).toJSON ? new Order(item) : <Order>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.passworld = _data["passworld"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.about = _data["about"];
            if (Array.isArray(_data["comments"])) {
                (<any>this).comments = [] as any;
                for (let item of _data["comments"])
                    (<any>this).comments!.push(Comment.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["feedbacks"])) {
                (<any>this).feedbacks = [] as any;
                for (let item of _data["feedbacks"])
                    (<any>this).feedbacks!.push(Feedback.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["orders"])) {
                (<any>this).orders = [] as any;
                for (let item of _data["orders"])
                    (<any>this).orders!.push(Order.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): User | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<User>(data, _mappings, User);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["passworld"] = this.passworld;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["about"] = this.about;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.feedbacks)) {
            data["feedbacks"] = [];
            for (let item of this.feedbacks)
                data["feedbacks"].push(item.toJSON());
        }
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    userId?: number;
    email?: string | undefined;
    passworld?: string | undefined;
    name?: string | undefined;
    phone?: number | undefined;
    address?: string | undefined;
    birthday?: Date | undefined;
    status?: boolean | undefined;
    about?: string | undefined;
    comments?: IComment[] | undefined;
    feedbacks?: IFeedback[] | undefined;
    orders?: IOrder[] | undefined;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}